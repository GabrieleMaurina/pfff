(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_tof.cmo  pr_o.cmo /tmp/xxx.ml  *)

let tof_tok = Ocaml.add_new_type "tok" (Ocaml.TTODO "")
  
let tof_wrap =
  Ocaml.add_new_type "wrap" (Ocaml.Tuple [ Ocaml.Poly "a"; Ocaml.Var "tok" ])
  
let tof_name =
  Ocaml.add_new_type "name" (Ocaml.Apply (("wrap", Ocaml.String)))
  
let tof_dotted_name =
  Ocaml.add_new_type "dotted_name" (Ocaml.List (Ocaml.Var "name"))
  
let tof_qualified_name =
  Ocaml.add_new_type "qualified_name" (Ocaml.Var "dotted_name")
  
let tof_module_name =
  Ocaml.add_new_type "module_name"
    (Ocaml.Sum
       [ ("FileName", [ Ocaml.Apply (("wrap", Ocaml.String)) ]);
         ("DottedName", [ Ocaml.Var "dotted_name" ]) ])
  
let tof_resolved_name =
  Ocaml.add_new_type "resolved_name"
    (Ocaml.Sum
       [ ("Local", []); ("Param", []);
         ("Global", [ Ocaml.Var "qualified_name" ]); ("NotResolved", []);
         ("Macro", []); ("EnumConstant", []); ("ImportedModule", []) ])

let tof_xml = Ocaml.add_new_type "xml" (Ocaml.List (Ocaml.Var "any"))
  
let tof_any =
  Ocaml.add_new_type "any"
    (Ocaml.Sum
       [ ("N", [ Ocaml.Var "name" ]); ("En", [ Ocaml.Var "entity" ]);
         ("E", [ Ocaml.Var "expr" ]); ("S", [ Ocaml.Var "stmt" ]);
         ("T", [ Ocaml.Var "type_" ]); ("P", [ Ocaml.Var "pattern" ]);
         ("D", [ Ocaml.Var "definition" ]);
         ("Di", [ Ocaml.Var "directive" ]); ("I", [ Ocaml.Var "item" ]);
         ("Pa", [ Ocaml.Var "parameter" ]); ("Ar", [ Ocaml.Var "argument" ]);
         ("At", [ Ocaml.Var "attribute" ]);
         ("Dk", [ Ocaml.Var "definition_kind" ]);
         ("Pr", [ Ocaml.Var "program" ]) ])


and tof_program =
  Ocaml.add_new_type "program" (Ocaml.List (Ocaml.Var "item"))
and tof_item =
  Ocaml.add_new_type "item"
    (Ocaml.Sum
       [ ("IStmt", [ Ocaml.Var "stmt" ]);
         ("IDef", [ Ocaml.Var "definition" ]);
         ("IDir", [ Ocaml.Var "directive" ]) ])
and tof_other_directive_operator =
  Ocaml.add_new_type "other_directive_operator"
    (Ocaml.Sum
       [ ("OI_Export", []); ("OI_ImportCss", []); ("OI_ImportEffect", []);
         ("OI_Package", []); ("OI_Define", []); ("OI_Macro", []);
         ("OI_Prototype", []); ("OI_Namespace", []) ])
and tof_alias =
  Ocaml.add_new_type "alias"
    (Ocaml.Tuple [ Ocaml.Var "name"; Ocaml.Option (Ocaml.Var "name") ])
and tof_directive =
  Ocaml.add_new_type "directive"
    (Ocaml.Sum
       [ ("Import",
          [ Ocaml.Var "module_name"; Ocaml.List (Ocaml.Var "alias") ]);
         ("ImportAll",
          [ Ocaml.Var "module_name"; Ocaml.Option (Ocaml.Var "name") ]);
         ("OtherDirective",
          [ Ocaml.Var "other_directive_operator";
            Ocaml.List (Ocaml.Var "any") ]) ])
and tof_class_kind =
  Ocaml.add_new_type "class_kind"
    (Ocaml.Sum [ ("Class", []); ("Interface", []); ("Trait", []) ])
and tof_class_definition =
  Ocaml.add_new_type "class_definition"
    (Ocaml.Dict
       [ ("ckind", `RO, (Ocaml.Var "class_kind"));
         ("cextends", `RO, (Ocaml.List (Ocaml.Var "type_")));
         ("cimplements", `RO, (Ocaml.List (Ocaml.Var "type_")));
         ("cbody", `RO, (Ocaml.List (Ocaml.Var "field"))) ])
and tof_other_type_definition_operator =
  Ocaml.add_new_type "other_type_definition_operator"
    (Ocaml.Sum [ ("OTDO_Struct", []); ("OTDO_Union", []); ("OTDO_Enum", []) ])
and tof_constructor_definition =
  Ocaml.add_new_type "constructor_definition"
    (Ocaml.Tuple [ Ocaml.Var "name"; Ocaml.List (Ocaml.Var "type_") ])
and tof_other_type_kind_operator =
  Ocaml.add_new_type "other_type_kind_operator"
    (Ocaml.Sum [ ("OTKO_EnumWithValue", []) ])
and tof_type_definition_kind =
  Ocaml.add_new_type "type_definition_kind"
    (Ocaml.Sum
       [ ("OrType", [ Ocaml.List (Ocaml.Var "constructor_definition") ]);
         ("AndType", [ Ocaml.List (Ocaml.Var "field") ]);
         ("AliasType", [ Ocaml.Var "type_" ]);
         ("OtherTypeKind",
          [ Ocaml.Var "other_type_kind_operator";
            Ocaml.List (Ocaml.Var "any") ]) ])
and tof_type_definition =
  Ocaml.add_new_type "type_definition"
    (Ocaml.Dict
       [ ("tbody", `RO, (Ocaml.Var "type_definition_kind"));
         ("tother", `RO, (Ocaml.Var "other_type_definition_operator")) ])
and tof_field =
  Ocaml.add_new_type "field"
    (Ocaml.Sum
       [ ("FieldVar",
          [ Ocaml.Var "entity"; Ocaml.Var "variable_definition" ]);
         ("FieldMethod",
          [ Ocaml.Var "entity"; Ocaml.Var "function_definition" ]);
         ("FieldDynamic",
          [ Ocaml.Var "expr"; Ocaml.List (Ocaml.Var "attribute");
            Ocaml.Var "expr" ]);
         ("FieldSpread", [ Ocaml.Var "expr" ]);
         ("FieldStmt", [ Ocaml.Var "stmt" ]) ])
and tof_variable_definition =
  Ocaml.add_new_type "variable_definition"
    (Ocaml.Dict
       [ ("vinit", `RO, (Ocaml.Option (Ocaml.Var "expr")));
         ("vtype", `RO, (Ocaml.Option (Ocaml.Var "type_"))) ])
and tof_other_parameter_operator =
  Ocaml.add_new_type "other_parameter_operator"
    (Ocaml.Sum [ ("OPO_KwdParam", []); ("OPO_Ref", []) ])
and tof_parameter_classic =
  Ocaml.add_new_type "parameter_classic"
    (Ocaml.Dict
       [ ("pname", `RO, (Ocaml.Var "name"));
         ("pdefault", `RO, (Ocaml.Option (Ocaml.Var "expr")));
         ("ptype", `RO, (Ocaml.Option (Ocaml.Var "type_")));
         ("pattrs", `RO, (Ocaml.List (Ocaml.Var "attribute"))) ])
and tof_parameter =
  Ocaml.add_new_type "parameter"
    (Ocaml.Sum
       [ ("ParamClassic", [ Ocaml.Var "parameter_classic" ]);
         ("ParamPattern", [ Ocaml.Var "pattern" ]);
         ("OtherParam",
          [ Ocaml.Var "other_parameter_operator";
            Ocaml.List (Ocaml.Var "any") ]) ])
and tof_parameters =
  Ocaml.add_new_type "parameters" (Ocaml.List (Ocaml.Var "parameter"))
and tof_function_definition =
  Ocaml.add_new_type "function_definition"
    (Ocaml.Dict
       [ ("fparams", `RO, (Ocaml.Var "parameters"));
         ("frettype", `RO, (Ocaml.Option (Ocaml.Var "type_")));
         ("fbody", `RO, (Ocaml.Var "stmt")) ])
and tof_type_parameter_constraint =
  Ocaml.add_new_type "type_parameter_constraint"
    (Ocaml.Sum [ ("Extends", [ Ocaml.Var "type_" ]) ])
and tof_type_parameter_constraints =
  Ocaml.add_new_type "type_parameter_constraints"
    (Ocaml.List (Ocaml.Var "type_parameter_constraint"))
and tof_type_parameter =
  Ocaml.add_new_type "type_parameter"
    (Ocaml.Tuple [ Ocaml.Var "name"; Ocaml.Var "type_parameter_constraints" ])
and tof_definition_kind =
  Ocaml.add_new_type "definition_kind"
    (Ocaml.Sum
       [ ("FuncDef", [ Ocaml.Var "function_definition" ]);
         ("VarDef", [ Ocaml.Var "variable_definition" ]);
         ("ClassDef", [ Ocaml.Var "class_definition" ]);
         ("TypeDef", [ Ocaml.Var "type_definition" ]);
         ("ModuleDef", [ Ocaml.Var "module_definition" ]);
         ("MacroDef", [ Ocaml.Var "macro_definition" ]);
         ("Signature", [ Ocaml.Var "type_" ]);
 ])

and tof_macro_definition =
  Ocaml.add_new_type "macro_definition"
    (Ocaml.Dict
       [ ("macroparams", `RO, (Ocaml.List (Ocaml.Var "ident")));
         ("macrobody", `RO, (Ocaml.List (Ocaml.Var "any"))) ])
and tof_other_module_operator =
  Ocaml.add_new_type "other_module_operator"
    (Ocaml.Sum [ ("OMO_Functor", []) ])
and tof_module_definition_kind =
  Ocaml.add_new_type "module_definition_kind"
    (Ocaml.Sum
       [ ("ModuleAlias", [ Ocaml.Var "name" ]);
         ("ModuleStruct",
          [ Ocaml.Option (Ocaml.Var "dotted_ident");
            Ocaml.List (Ocaml.Var "item") ]);
         ("OtherModule",
          [ Ocaml.Var "other_module_operator"; Ocaml.List (Ocaml.Var "any") ]) ])
and tof_module_definition =
  Ocaml.add_new_type "module_definition"
    (Ocaml.Dict [ ("mbody", `RO, (Ocaml.Var "module_definition_kind")) ])

and tof_entity =
  Ocaml.add_new_type "entity"
    (Ocaml.Dict
       [ ("name", `RO, (Ocaml.Var "name"));
         ("attrs", `RO, (Ocaml.List (Ocaml.Var "attribute")));
         ("type_", `RO, (Ocaml.Option (Ocaml.Var "type_")));
         ("tparams", `RO, (Ocaml.List (Ocaml.Var "type_parameter"))) ])
and tof_definition =
  Ocaml.add_new_type "definition"
    (Ocaml.Tuple [ Ocaml.Var "entity"; Ocaml.Var "definition_kind" ])
and tof_other_pattern_operator =
  Ocaml.add_new_type "other_pattern_operator"
    (Ocaml.Sum [ ("OP_Expr", []); ("OP_Var", []) ])
and tof_pattern =
  Ocaml.add_new_type "pattern"
    (Ocaml.Sum
       [ ("PatVar", [ Ocaml.Var "name" ]);
         ("PatLiteral", [ Ocaml.Var "literal" ]);
         ("PatConstructor",
          [ Ocaml.Var "name"; Ocaml.List (Ocaml.Var "pattern") ]);
         ("PatTuple", [ Ocaml.List (Ocaml.Var "pattern") ]);
         ("PatList", [ Ocaml.List (Ocaml.Var "pattern") ]);
         ("PatKeyVal", [ Ocaml.Var "pattern"; Ocaml.Var "pattern" ]);
         ("PatUnderscore", [ Ocaml.Var "tok" ]);
         ("PatDisj", [ Ocaml.Var "pattern"; Ocaml.Var "pattern" ]);
         ("PatTyped", [ Ocaml.Var "pattern"; Ocaml.Var "type_" ]);
         ("OtherPat",
          [ Ocaml.Var "other_pattern_operator"; Ocaml.List (Ocaml.Var "any") ]) ])
and tof_other_stmt_operator =
  Ocaml.add_new_type "other_stmt_operator"
    (Ocaml.Sum
       [ ("OS_Delete", []); ("OS_Print", []); ("OS_ForOrElse", []);
         ("OS_WhileOrElse", []); ("OS_TryOrElse", []); ("OS_With", []);
         ("OS_ThrowFrom", []); ("OS_ThrowNothing", []); ("OS_Global", []);
         ("OS_NonLocal", []); ("OS_Pass", []); ("OS_Sync", []);
         ("OS_Asm", []) ])
and tof_for_var_or_expr =
  Ocaml.add_new_type "for_var_or_expr"
    (Ocaml.Sum
       [ ("ForInitVar",
          [ Ocaml.Var "entity"; Ocaml.Var "variable_definition" ]);
         ("ForInitExpr", [ Ocaml.Var "expr" ]) ])
and tof_for_header =
  Ocaml.add_new_type "for_header"
    (Ocaml.Sum
       [ ("ForClassic",
          [ Ocaml.List (Ocaml.Var "for_var_or_expr"); Ocaml.Var "expr";
            Ocaml.Var "expr" ]);
         ("ForEach", [ Ocaml.Var "pattern"; Ocaml.Var "expr" ]) ])
and tof_label = Ocaml.add_new_type "label" (Ocaml.Var "name")
and tof_finally = Ocaml.add_new_type "finally" (Ocaml.Var "stmt")
and tof_catch =
  Ocaml.add_new_type "catch"
    (Ocaml.Tuple [ Ocaml.Var "pattern"; Ocaml.Var "stmt" ])
and tof_case =
  Ocaml.add_new_type "case"
    (Ocaml.Sum [ ("Case", [ Ocaml.Var "expr" ]); ("Default", []) ])
and tof_case_and_body =
  Ocaml.add_new_type "case_and_body"
    (Ocaml.Tuple [ Ocaml.List (Ocaml.Var "case"); Ocaml.Var "stmt" ])
and tof_stmt =
  Ocaml.add_new_type "stmt"
    (Ocaml.Sum
       [ ("ExprStmt", [ Ocaml.Var "expr" ]);
         ("LocalDef", [ Ocaml.Var "definition" ]);
         ("LocalDirective", [ Ocaml.Var "directive" ]);
         ("Block", [ Ocaml.List (Ocaml.Var "stmt") ]);
         ("If", [ Ocaml.Var "expr"; Ocaml.Var "stmt"; Ocaml.Var "stmt" ]);
         ("While", [ Ocaml.Var "expr"; Ocaml.Var "stmt" ]);
         ("DoWhile", [ Ocaml.Var "stmt"; Ocaml.Var "expr" ]);
         ("For", [ Ocaml.Var "for_header"; Ocaml.Var "stmt" ]);
         ("Switch",
          [ Ocaml.Var "expr"; Ocaml.List (Ocaml.Var "case_and_body") ]);
         ("Return", [ Ocaml.Var "expr" ]);
         ("Continue", [ Ocaml.Option (Ocaml.Var "expr") ]);
         ("Break", [ Ocaml.Option (Ocaml.Var "expr") ]);
         ("Label", [ Ocaml.Var "label"; Ocaml.Var "stmt" ]);
         ("Goto", [ Ocaml.Var "label" ]); ("Throw", [ Ocaml.Var "expr" ]);
         ("Try",
          [ Ocaml.Var "stmt"; Ocaml.List (Ocaml.Var "catch");
            Ocaml.Option (Ocaml.Var "finally") ]);
         ("Assert", [ Ocaml.Var "expr"; Ocaml.Option (Ocaml.Var "expr") ]);
         ("OtherStmt",
          [ Ocaml.Var "other_stmt_operator"; Ocaml.List (Ocaml.Var "any") ]) ])
and tof_other_attribute_operator =
  Ocaml.add_new_type "other_attribute_operator"
    (Ocaml.Sum
       [ ("OA_StrictFP", []); ("OA_Transient", []); ("OA_Synchronized", []);
         ("OA_Native", []); ("OA_AnnotJavaOther", [ Ocaml.String ]);
         ("OA_AnnotThrow", []); ("OA_Expr", []) ])
and tof_attribute =
  Ocaml.add_new_type "attribute"
    (Ocaml.Sum
       [ ("Static", []); ("Volatile", []); ("Extern", []); ("Public", []);
         ("Private", []); ("Protected", []); ("Abstract", []); ("Final", []);
         ("Var", []); ("Let", []); ("Const", []); ("Generator", []);
         ("Async", []); ("Ctor", []); ("Dtor", []); ("Getter", []);
         ("Setter", []); ("Variadic", []);
         ("NamedAttr", [ Ocaml.Var "name"; Ocaml.List (Ocaml.Var "any") ]);
         ("OtherAttribute",
          [ Ocaml.Var "other_attribute_operator";
            Ocaml.List (Ocaml.Var "any") ]) ])
and tof_other_type_operator =
  Ocaml.add_new_type "other_type_operator"
    (Ocaml.Sum
       [ ("OT_Expr", []); ("OT_Arg", []); ("OT_StructName", []);
         ("OT_UnionName", []); ("OT_EnumName", []); ("OT_Shape", []);
         ("OT_Variadic", []) ])
and tof_other_type_argument_operator =
  Ocaml.add_new_type "other_type_argument_operator"
    (Ocaml.Sum [ ("OTA_Question", []) ])
and tof_type_argument =
  Ocaml.add_new_type "type_argument"
    (Ocaml.Sum
       [ ("TypeArg", [ Ocaml.Var "type_" ]);
         ("OtherTypeArg",
          [ Ocaml.Var "other_type_argument_operator";
            Ocaml.List (Ocaml.Var "any") ]) ])
and tof_type_arguments =
  Ocaml.add_new_type "type_arguments"
    (Ocaml.List (Ocaml.Var "type_argument"))
and tof_type_ =
  Ocaml.add_new_type "type_"
    (Ocaml.Sum
       [ ("TyBuiltin", [ Ocaml.Apply (("wrap", Ocaml.String)) ]);
         ("TyFun", [ Ocaml.List (Ocaml.Var "type_"); Ocaml.Var "type_" ]);
         ("TyApply", [ Ocaml.Var "name"; Ocaml.Var "type_arguments" ]);
         ("TyVar", [ Ocaml.Var "name" ]);
         ("TyArray", [ Ocaml.Option (Ocaml.Var "expr"); Ocaml.Var "type_" ]);
         ("TyPointer", [ Ocaml.Var "type_" ]);
         ("TyTuple", [ Ocaml.List (Ocaml.Var "type_") ]);
         ("TyQuestion", [ Ocaml.Var "type_" ]);
         ("OtherType",
          [ Ocaml.Var "other_type_operator"; Ocaml.List (Ocaml.Var "any") ]) ])
and tof_other_expr_operator =
  Ocaml.add_new_type "other_expr_operator"
    (Ocaml.Sum
       [ ("OE_Exports", []); ("OE_Module", []); ("OE_Define", []);
         ("OE_Arguments", []); ("OE_NewTarget", []); ("OE_Delete", []);
         ("OE_YieldStar", []); ("OE_Encaps", []); ("OE_Require", []);
         ("OE_UseStrict", []); ("OE_ObjAccess_PN_Computed", []);
         ("OE_ExprClass", []); ("OE_Imag", []); ("OE_Is", []);
         ("OE_IsNot", []); ("OE_In", []); ("OE_NotIn", []);
         ("OE_Invert", []); ("OE_Slice", []); ("OE_SliceIndex", []);
         ("OE_SliceRange", []); ("OE_CompForIf", []); ("OE_CompFor", []);
         ("OE_CompIf", []); ("OE_CmpOps", []); ("OE_Repr", []);
         ("OE_NameOrClassType", []); ("OE_ClassLiteral", []);
         ("OE_RecordPtAccess", []); ("OE_SizeOf", []);
         ("OE_ArrayInitDesignator", []); ("OE_GccConstructor", []);
         ("OE_Unpack", []) ])
and tof_action =
  Ocaml.add_new_type "action"
    (Ocaml.Tuple [ Ocaml.Var "pattern"; Ocaml.Var "expr" ])
and tof_other_argument_operator =
  Ocaml.add_new_type "other_argument_operator"
    (Ocaml.Sum [ ("OA_ArgPow", []); ("OA_ArgComp", []) ])
and tof_argument =
  Ocaml.add_new_type "argument"
    (Ocaml.Sum
       [ ("Arg", [ Ocaml.Var "expr" ]);
         ("ArgKwd", [ Ocaml.Var "name"; Ocaml.Var "expr" ]);
         ("ArgOther",
          [ Ocaml.Var "other_argument_operator"; Ocaml.List (Ocaml.Var "any") ]) ])
and tof_arguments =
  Ocaml.add_new_type "arguments" (Ocaml.List (Ocaml.Var "argument"))
and tof_arithmetic_operator =
  Ocaml.add_new_type "arithmetic_operator"
    (Ocaml.Sum
       [ ("Plus", []); ("Minus", []); ("Mult", []); ("Div", []); ("Mod", []);
         ("Pow", []); ("FloorDiv", []); ("LSL", []); ("LSR", []);
         ("ASR", []); ("BitOr", []); ("BitXor", []); ("BitAnd", []);
         ("BitNot", []); ("And", []); ("Or", []); ("Not", []); ("Eq", []);
         ("NotEq", []); ("PhysEq", []); ("NotPhysEq", []); ("Lt", []);
         ("LtE", []); ("Gt", []); ("GtE", []) ])
and tof_special =
  Ocaml.add_new_type "special"
    (Ocaml.Sum
       [ ("This", []); ("Super", []); ("Self", []); ("Parent", []);
         ("Eval", []); ("Typeof", []); ("Instanceof", []); ("New", []);
         ("Concat", []); ("Spread", []);
         ("ArithOp", [ Ocaml.Var "arithmetic_operator" ]);
         ("IncrDecr", [ Ocaml.Bool; Ocaml.Bool ]) ])
and tof_id_info =
  Ocaml.add_new_type "id_info"
    (Ocaml.Dict
       [ ("id_qualifier", `RO, (Ocaml.Option (Ocaml.Var "dotted_name")));
         ("id_typeargs", `RO, (Ocaml.Option (Ocaml.Var "type_arguments")));
         ("id_resolved", `RO,
          (Ocaml.Apply (("ref", (Ocaml.Var "resolved_name")))));
         ("id_type", `RO,
          (Ocaml.Apply (("ref", (Ocaml.Option (Ocaml.Var "type_")))))) ])
and tof_container_operator =
  Ocaml.add_new_type "container_operator"
    (Ocaml.Sum [ ("Array", []); ("List", []); ("Set", []); ("Dict", []) ])
and tof_literal =
  Ocaml.add_new_type "literal"
    (Ocaml.Sum
       [ ("Unit", [ Ocaml.Var "tok" ]);
         ("Bool", [ Ocaml.Apply (("wrap", Ocaml.Bool)) ]);
         ("Int", [ Ocaml.Apply (("wrap", Ocaml.String)) ]);
         ("Float", [ Ocaml.Apply (("wrap", Ocaml.String)) ]);
         ("Char", [ Ocaml.Apply (("wrap", Ocaml.String)) ]);
         ("String", [ Ocaml.Apply (("wrap", Ocaml.String)) ]);
         ("Regexp", [ Ocaml.Apply (("wrap", Ocaml.String)) ]);
         ("Null", [ Ocaml.Var "tok" ]); ("Undefined", [ Ocaml.Var "tok" ]) ])
and tof_expr =
  Ocaml.add_new_type "expr"
    (Ocaml.Sum
       [ ("L", [ Ocaml.Var "literal" ]);
         ("Container",
          [ Ocaml.Var "container_operator"; Ocaml.List (Ocaml.Var "expr") ]);
         ("Tuple", [ Ocaml.List (Ocaml.Var "expr") ]);
         ("Record", [ Ocaml.List (Ocaml.Var "field") ]);
         ("Constructor", [ Ocaml.Var "name"; Ocaml.List (Ocaml.Var "expr") ]);
         ("Lambda", [ Ocaml.Var "parameters"; Ocaml.Var "stmt" ]);
         ("Nop", []); ("Id", [ Ocaml.Var "name"; Ocaml.Var "id_info" ]);
         ("IdSpecial", [ Ocaml.Var "special" ]);
         ("Call", [ Ocaml.Var "expr"; Ocaml.Var "arguments" ]);
         ("Xml", [ Ocaml.Var "xml" ]);
         ("Assign", [ Ocaml.Var "expr"; Ocaml.Var "expr" ]);
         ("AssignOp",
          [ Ocaml.Var "expr"; Ocaml.Var "arithmetic_operator";
            Ocaml.Var "expr" ]);
         ("LetPattern", [ Ocaml.Var "pattern"; Ocaml.Var "expr" ]);
         ("ObjAccess", [ Ocaml.Var "expr"; Ocaml.Var "name" ]);
         ("ArrayAccess", [ Ocaml.Var "expr"; Ocaml.Var "expr" ]);
         ("Conditional",
          [ Ocaml.Var "expr"; Ocaml.Var "expr"; Ocaml.Var "expr" ]);
         ("MatchPattern",
          [ Ocaml.Var "expr"; Ocaml.List (Ocaml.Var "action") ]);
         ("Yield", [ Ocaml.Var "expr" ]); ("Await", [ Ocaml.Var "expr" ]);
         ("Cast", [ Ocaml.Var "type_"; Ocaml.Var "expr" ]);
         ("Seq", [ Ocaml.List (Ocaml.Var "expr") ]);
         ("Ref", [ Ocaml.Var "expr" ]); ("DeRef", [ Ocaml.Var "expr" ]);
         ("Ellipses", [ Ocaml.Var "tok" ]);
         ("OtherExpr",
          [ Ocaml.Var "other_expr_operator"; Ocaml.List (Ocaml.Var "any") ]) ])
  
