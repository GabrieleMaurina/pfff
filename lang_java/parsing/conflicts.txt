# -*- org -*-

* Conflicts in Java 1.0

A great prelimiary writeup to read on conflicts is the official
LALR grammar comments in the 1st edition of the Java specification, which is
still accessible at https://www.cs.cornell.edu/andru/javaspec/19.doc.html
(also cached in pfff/docs/official-grammars/java/).

** Different names for different entities
See the writeup above pb #1.
Led to just having a general Name non terminal.

** Different modifiers for different entities
See the writeup above pb #2.
Led to just having a general Modifiers non terminal.

** Field declaration vs method declaration
See the writeup above pb #3.
Led to inline ResultType in MethodHeader.

** Array type vs array access.
See the writeup above pb #4.
Led to inline Type def in ArrayType.

** Cast vs parenthesized expression
See the writeup above pb #5.
Led to generalize CastExpression and inline some of ReferenceType.

* modifiers vs modifiers_opt

In many places we can not use modifiers_opt (or one of its variant
like variable_modifiers_opt) but have instead to inline its content
and create in the parent 2 alternatives like

ruleA:
|  modifiers XXX { }
|            XXX { }

This is usually when XXX can be a type or an identifier.
Seeing an identifier, which can be start of a type, yacc does not know
if it can reduce modifiers_opt. It needs to read more than the next
ident to know if this is the start of a declaration with a modifier and a type
or a simple identifier.

ex: lambda_param.


* When add generics

We can have expressions like:
 i<b;
and type declarations like
 i<b> x;

hence an ambiguity which requires some lookahead or semantic information
to know what is 'i' (is it a type name?).

solutions?
 - (1) use a GLR parser
 - (2) c/c++ parser trick to tag differently <
 - (3) parser trick to tag differently typedef and idents

I currently use #3.

* when add generic methods

* Lambda

