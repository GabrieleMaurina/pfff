(* Yoann Padioleau
 *
 * Copyright (C) 2019 Yoann Padioleau
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * This module provides a big functor, JS_VS_JS, which can be used
 * to match some AST elements against other AST elements in
 * a flexible way.
 *
 * Most of the boilerplate code was copy-pasted from php_vs_php.ml
 * or generated by
 *
 *    pfff/meta/gen_code -matcher_gen_all ast_js.ml
 *
 * using OCaml pad-style reflection (see commons/ocaml.ml) on
 * parsing_js/ast_js.ml.
 *
 * See pfff/matcher/fuzzy_vs_fuzzy.ml for another approach.
 *
 * I then hardcoded a few isomorphisms by abusing some existing constructs,
 * for instance constants starting with a big X are considered metavars
 * for expression.
 *
 * C-s "pad" or "iso" or any comment
 *
 *)

(* A is the pattern, and B the concrete source code. For now
 * we both use the same module, Ast_php, but they may differ later
 * as the expressivity of the pattern language grows.
 *
 * subtle: use 'b' for to report errors, 'a' is the sgrep pattern and it
 * has no file information usually.
 *)
module A = Ast_js
module B = Ast_js

module MV = Metavars_js

(*****************************************************************************)
(* Globals *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(*****************************************************************************)
(* Functor parameter combinators *)
(*****************************************************************************)

(* This is the interface of the structure that will be passed to the
 * functor below.
 *)
module type PARAM =
  sig
    (* tin is for 'type in' and tout for 'type out' *)
    type tin
    type 'x tout

    (* A matcher is something taking an element A and an element B
     * (for PHP_VS_PHP below, A will be the AST of the PHP pattern and B
     * the AST of the PHP program we want to match over), then some environment
     * information tin, and it will return something (tout) that will
     * encapsulate the possible matched element A and B.
     *
     * If you just want to do a simple matcher that just returns
     * a boolean, then instantiate the PARAM struct with
     *   type tin = unit  (* no environment information *)
     *   type ('a * 'b) tout = ('a * 'b) option
     * and if the toplevel matching returns a None, then you know
     * A didn't match B.
     *)
    type ('a, 'b) matcher = 'a -> 'b  -> tin -> ('a * 'b) tout

    (* The >>= combinator below allow you to configure the matching process
     * anyway you want. Essentially this combinator takes a matcher,
     * another matcher, and returns a matcher that combine the 2
     * matcher arguments.
     *
     * In the case of a simple boolean matcher, you just need to write:
     *
     *   let (>>=) m1 m2 = fun tin ->
     *    match m1 tin with
     *    | None -> None
     *    | Some (a,b) ->
     *        m2 (a, b) tin
     *)
    val (>>=):
      (tin -> ('a * 'b) tout)  ->
      ('a * 'b -> (tin -> ('c * 'd) tout)) ->
      (tin -> ('c * 'd) tout)


    (* the disjunctive combinator *)
    val (>||>) :
      (tin -> 'x tout) ->
      (tin -> 'x tout) ->
      (tin -> 'x tout)


    (* The classical monad combinators *)
    val return : ('a * 'b) -> tin -> ('a *'b) tout
    val fail : tin -> ('a * 'b) tout

    val tokenf : (A.tok, B.tok) matcher

    val envf : (MV.mvar A.wrap, A.any) matcher
    (* ugly hack for the "A" string metavariables *)
    val envf2 : (MV.mvar A.wrap, A.any * A.any) matcher
  end

(*****************************************************************************)
(* Functor code, "JS vs JS" *)
(*****************************************************************************)

module JS_VS_JS =
  functor (X : PARAM) ->
struct

type ('a, 'b) matcher = 'a -> 'b  -> X.tin -> ('a * 'b) X.tout

let (>>=) = X.(>>=)
let (>||>) = X.(>||>)

let return =
  X.return
let fail () =
  X.fail

let fail2 s =
  pr2 (spf "JS_VS_JS: TODO for %s" s); X.fail

(* ---------------------------------------------------------------------- *)
(* stdlib: option, list, ref, either, bool *)
(* ---------------------------------------------------------------------- *)
let (m_option: ('a,'b) matcher -> ('a option,'b option) matcher) = fun f a b ->
  match a, b with
  | None, None -> return (None, None)
  | Some xa, Some xb ->
      f xa xb >>= (fun (xa, xb) ->
        return (
          Some xa,
          Some xb
        )
      )
  | None, _
  | Some _, _
      -> fail ()

let (m_ref: ('a,'b) matcher -> ('a ref,'b ref) matcher) = fun f a b ->
  match a, b with
  { contents = xa}, { contents = xb} ->
    f xa xb >>= (fun (xa, xb) ->
      return (
        {contents = xa},
        {contents = xb}
      )
    )

let rec m_list f a b =
  match a, b with
  | [], [] ->
      return ([], [])
  | xa::aas, xb::bbs ->
      f xa xb >>= (fun (xa, xb) ->
      m_list f aas bbs >>= (fun (aas, bbs) ->
        return (
          xa::aas,
          xb::bbs
        )
      )
      )
  | [], _
  | _::_, _ ->
      fail ()

let m_either f g a b =
  match a, b with
  | Left a, Left b ->
      f a b >>= (fun (a, b) ->
        return (
          Left a, Left b
        ))
  | Right a, Right b ->
      g a b >>= (fun (a, b) ->
        return (
          Right a, Right b
        ))
  | Left _, Right _
  | Right _, Left _ ->
      fail ()

let m_bool a b = if a = b then return (a,b) else fail ()

(* ---------------------------------------------------------------------- *)
(* m_string *)
(* ---------------------------------------------------------------------- *)
let m_string a b =
  if a =$= b then return (a, b) else fail ()

(* ---------------------------------------------------------------------- *)
(* tokens *)
(* ---------------------------------------------------------------------- *)

(* we dont care about position, space/indent/comment isomorphism
 * so we could just do  'return (a, b)'
 * but we need to propagate transformation at least.
 *)
let m_info a b =
  X.tokenf a b

let m_tok a b = m_info a b

let m_wrap f a b =
  match a, b with
  ((xaa, ainfo), (xbb, binfo)) ->
    f xaa xbb >>= (fun (xaa, xbb) ->
    m_info ainfo binfo >>= (fun (ainfo, binfo) ->
      return (
        (xaa, ainfo),
        (xbb, binfo)
      )
  ))

(* ---------------------------------------------------------------------- *)
(* names *)
(* ---------------------------------------------------------------------- *)
let m_name a b = 
  match a, b with
  (a, b) -> (m_wrap m_string) a b

let m_qualified_name = m_string

let m_filename = m_wrap m_string

let m_label a b = 
  match a, b with
  (a, b) -> (m_wrap m_string) a b

let m_resolved_name a b = 
  match a, b with
  | A.Local, B.Local ->
    return (
       A.Local,
       B.Local
    )
  | A.Param, B.Param ->
    return (
       A.Param,
       B.Param
    )
  | A.Global(a1), B.Global(b1) ->
    m_qualified_name a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Global(a1),
       B.Global(b1)
    )
    )
  | A.NotResolved, B.NotResolved ->
    return (
       A.NotResolved,
       B.NotResolved
    )
  | A.Local, _
  | A.Param, _
  | A.Global _, _
  | A.NotResolved, _
   -> fail ()

let m_special a b = 
  match a, b with
  | A.Null, B.Null ->
    return (
       A.Null,
       B.Null
    )
  | A.Undefined, B.Undefined ->
    return (
       A.Undefined,
       B.Undefined
    )
  | A.This, B.This ->
    return (
       A.This,
       B.This
    )
  | A.Super, B.Super ->
    return (
       A.Super,
       B.Super
    )
  | A.Exports, B.Exports ->
    return (
       A.Exports,
       B.Exports
    )
  | A.Module, B.Module ->
    return (
       A.Module,
       B.Module
    )
  | A.New, B.New ->
    return (
       A.New,
       B.New
    )
  | A.NewTarget, B.NewTarget ->
    return (
       A.NewTarget,
       B.NewTarget
    )
  | A.Eval, B.Eval ->
    return (
       A.Eval,
       B.Eval
    )
  | A.Require, B.Require ->
    return (
       A.Require,
       B.Require
    )
  | A.Seq, B.Seq ->
    return (
       A.Seq,
       B.Seq
    )
  | A.Void, B.Void ->
    return (
       A.Void,
       B.Void
    )
  | A.Typeof, B.Typeof ->
    return (
       A.Typeof,
       B.Typeof
    )
  | A.Instanceof, B.Instanceof ->
    return (
       A.Instanceof,
       B.Instanceof
    )
  | A.In, B.In ->
    return (
       A.In,
       B.In
    )
  | A.Delete, B.Delete ->
    return (
       A.Delete,
       B.Delete
    )
  | A.Spread, B.Spread ->
    return (
       A.Spread,
       B.Spread
    )
  | A.Yield, B.Yield ->
    return (
       A.Yield,
       B.Yield
    )
  | A.YieldStar, B.YieldStar ->
    return (
       A.YieldStar,
       B.YieldStar
    )
  | A.Await, B.Await ->
    return (
       A.Await,
       B.Await
    )
  | A.Encaps(a1), B.Encaps(b1) ->
    (m_option m_name) a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Encaps(a1),
       B.Encaps(b1)
    )
    )
  | A.UseStrict, B.UseStrict ->
    return (
       A.UseStrict,
       B.UseStrict
    )
  | A.And, B.And ->
    return (
       A.And,
       B.And
    )
  | A.Or, B.Or ->
    return (
       A.Or,
       B.Or
    )
  | A.Not, B.Not ->
    return (
       A.Not,
       B.Not
    )
  | A.Xor, B.Xor ->
    return (
       A.Xor,
       B.Xor
    )
  | A.BitNot, B.BitNot ->
    return (
       A.BitNot,
       B.BitNot
    )
  | A.BitAnd, B.BitAnd ->
    return (
       A.BitAnd,
       B.BitAnd
    )
  | A.BitOr, B.BitOr ->
    return (
       A.BitOr,
       B.BitOr
    )
  | A.BitXor, B.BitXor ->
    return (
       A.BitXor,
       B.BitXor
    )
  | A.Lsr, B.Lsr ->
    return (
       A.Lsr,
       B.Lsr
    )
  | A.Asr, B.Asr ->
    return (
       A.Asr,
       B.Asr
    )
  | A.Lsl, B.Lsl ->
    return (
       A.Lsl,
       B.Lsl
    )
  | A.Equal, B.Equal ->
    return (
       A.Equal,
       B.Equal
    )
  | A.PhysEqual, B.PhysEqual ->
    return (
       A.PhysEqual,
       B.PhysEqual
    )
  | A.Lower, B.Lower ->
    return (
       A.Lower,
       B.Lower
    )
  | A.Greater, B.Greater ->
    return (
       A.Greater,
       B.Greater
    )
  | A.Plus, B.Plus ->
    return (
       A.Plus,
       B.Plus
    )
  | A.Minus, B.Minus ->
    return (
       A.Minus,
       B.Minus
    )
  | A.Mul, B.Mul ->
    return (
       A.Mul,
       B.Mul
    )
  | A.Div, B.Div ->
    return (
       A.Div,
       B.Div
    )
  | A.Mod, B.Mod ->
    return (
       A.Mod,
       B.Mod
    )
  | A.Expo, B.Expo ->
    return (
       A.Expo,
       B.Expo
    )
  | A.Incr(a1), B.Incr(b1) ->
    m_bool a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Incr(a1),
       B.Incr(b1)
    )
    )
  | A.Decr(a1), B.Decr(b1) ->
    m_bool a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Decr(a1),
       B.Decr(b1)
    )
    )
  | A.Null, _
  | A.Undefined, _
  | A.This, _
  | A.Super, _
  | A.Exports, _
  | A.Module, _
  | A.New, _
  | A.NewTarget, _
  | A.Eval, _
  | A.Require, _
  | A.Seq, _
  | A.Void, _
  | A.Typeof, _
  | A.Instanceof, _
  | A.In, _
  | A.Delete, _
  | A.Spread, _
  | A.Yield, _
  | A.YieldStar, _
  | A.Await, _
  | A.Encaps _, _
  | A.UseStrict, _
  | A.And, _
  | A.Or, _
  | A.Not, _
  | A.Xor, _
  | A.BitNot, _
  | A.BitAnd, _
  | A.BitOr, _
  | A.BitXor, _
  | A.Lsr, _
  | A.Asr, _
  | A.Lsl, _
  | A.Equal, _
  | A.PhysEqual, _
  | A.Lower, _
  | A.Greater, _
  | A.Plus, _
  | A.Minus, _
  | A.Mul, _
  | A.Div, _
  | A.Mod, _
  | A.Expo, _
  | A.Incr _, _
  | A.Decr _, _
   -> fail ()

(* start of recursive need *)

let rec m_property_name a b = 
  match a, b with
  | A.PN(a1), B.PN(b1) ->
    m_name a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.PN(a1),
       B.PN(b1)
    )
    )
  | A.PN_Computed(a1), B.PN_Computed(b1) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.PN_Computed(a1),
       B.PN_Computed(b1)
    )
    )
  | A.PN _, _
  | A.PN_Computed _, _
   -> fail ()

(* ---------------------------------------------------------------------- *)
(* operators *)
(* ---------------------------------------------------------------------- *)

(* ---------------------------------------------------------------------- *)
(* expr *)
(* ---------------------------------------------------------------------- *)

and m_expr a b = 
  match a, b with

  (* special case, metavars !! *)
  | A.Id ((name, info_name), aref), e2 when MV.is_metavar_name name ->
      X.envf (name, info_name) (B.Expr (e2)) >>= (function
      | ((name, info_name), B.Expr (e2))  ->
        return (
          (A.Id ((name,info_name), aref)),
          e2
        )
      | _ -> raise Impossible
      )

  (* pad, iso on variable name *)
  | A.Id ((name, info_name), aref), A.Id ((_name2, _info_name2), _aref2)
      when MV.is_metavar_variable_name name ->
      X.envf (name, info_name) (B.Expr b) >>= (function
      | ((name, info_name), B.Expr (b))  ->
        return (
          (A.Id ((name,info_name), aref)),
          b
        )
      | _ -> raise Impossible
      )

  | A.Bool(a1), B.Bool(b1) ->
    (m_wrap m_bool) a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Bool(a1),
       B.Bool(b1)
    )
    )
  | A.Num(a1), B.Num(b1) ->
    (m_wrap m_string) a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Num(a1),
       B.Num(b1)
    )
    )
  | A.String(a1), B.String(b1) ->
    (m_wrap m_string) a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.String(a1),
       B.String(b1)
    )
    )
  | A.Regexp(a1), B.Regexp(b1) ->
    (m_wrap m_string) a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Regexp(a1),
       B.Regexp(b1)
    )
    )
  | A.Id(a1, a2), B.Id(b1, b2) ->
    m_name a1 b1 >>= (fun (a1, b1) -> 
    (m_ref m_resolved_name) a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.Id(a1, a2),
       B.Id(b1, b2)
    )
    ))
  | A.IdSpecial(a1), B.IdSpecial(b1) ->
    (m_wrap m_special) a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.IdSpecial(a1),
       B.IdSpecial(b1)
    )
    )
  | A.Nop, B.Nop ->
    return (
       A.Nop,
       B.Nop
    )
  | A.Assign(a1, a2), B.Assign(b1, b2) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    m_expr a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.Assign(a1, a2),
       B.Assign(b1, b2)
    )
    ))
  | A.Obj(a1), B.Obj(b1) ->
    m_obj_ a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Obj(a1),
       B.Obj(b1)
    )
    )
  | A.Class(a1, a2), B.Class(b1, b2) ->
    m_class_ a1 b1 >>= (fun (a1, b1) -> 
    (m_option m_name) a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.Class(a1, a2),
       B.Class(b1, b2)
    )
    ))
  | A.ObjAccess(a1, a2), B.ObjAccess(b1, b2) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    m_property_name a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.ObjAccess(a1, a2),
       B.ObjAccess(b1, b2)
    )
    ))
  | A.Arr(a1), B.Arr(b1) ->
    (m_list m_expr) a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Arr(a1),
       B.Arr(b1)
    )
    )
  | A.ArrAccess(a1, a2), B.ArrAccess(b1, b2) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    m_expr a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.ArrAccess(a1, a2),
       B.ArrAccess(b1, b2)
    )
    ))
  | A.Fun(a1, a2), B.Fun(b1, b2) ->
    m_fun_ a1 b1 >>= (fun (a1, b1) -> 
    (m_option m_name) a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.Fun(a1, a2),
       B.Fun(b1, b2)
    )
    ))
  | A.Apply(a1, a2), B.Apply(b1, b2) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    (m_list_m_expr) a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.Apply(a1, a2),
       B.Apply(b1, b2)
    )
    ))
  | A.Conditional(a1, a2, a3), B.Conditional(b1, b2, b3) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    m_expr a2 b2 >>= (fun (a2, b2) -> 
    m_expr a3 b3 >>= (fun (a3, b3) -> 
    return (
       A.Conditional(a1, a2, a3),
       B.Conditional(b1, b2, b3)
    )
    )))
  | A.Bool _, _
  | A.Num _, _
  | A.String _, _
  | A.Regexp _, _
  | A.Id _, _
  | A.IdSpecial _, _
  | A.Nop, _
  | A.Assign _, _
  | A.Obj _, _
  | A.Class _, _
  | A.ObjAccess _, _
  | A.Arr _, _
  | A.ArrAccess _, _
  | A.Fun _, _
  | A.Apply _, _
  | A.Conditional _, _
   -> fail ()

(*---------------------------------------------------------------------------*)
(* arguments list iso *)
(*---------------------------------------------------------------------------*)
and m_list_m_expr xsa xsb =
  match xsa, xsb with
  | [], [] -> return ([], [])

  (* spread metavariable to match any arity *)
  | [A.Apply(A.IdSpecial (A.Spread, info_spread_TODO), 
        [A.Id((name, info_name), aref)])], 
    bbs 
    when MV.is_metavar_name name ->
      X.envf (name, info_name) (B.Expr (B.Apply (B.Nop, bbs))) >>= (function
      | ((name, info_name), (B.Expr (B.Apply (B.Nop, bbs))))  ->
        return (
          [A.Apply(A.IdSpecial (A.Spread, info_spread_TODO), 
              [A.Id((name, info_name), aref)])], 
          bbs 
        )
      | _ -> raise Impossible
      )
    
  | xa::aas, xb::bbs ->
    m_expr xa xb >>= (fun (xa, xb) ->
    m_list_m_expr aas bbs >>= (fun (aas, bbs) ->
      return (
        xa::aas,
        xb::bbs
     )))
  | [], _
  | _::_, _ ->
    fail ()

(*---------------------------------------------------------------------------*)
(* array list *)
(*---------------------------------------------------------------------------*)

(* ---------------------------------------------------------------------- *)
(* stmt *)
(* ---------------------------------------------------------------------- *)

and m_stmt a b = 
  match a, b with
  | A.VarDecl(a1), B.VarDecl(b1) ->
    m_var a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.VarDecl(a1),
       B.VarDecl(b1)
    )
    )
  | A.Block(a1), B.Block(b1) ->
    (m_list m_stmt) a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Block(a1),
       B.Block(b1)
    )
    )
  | A.ExprStmt(a1), B.ExprStmt(b1) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.ExprStmt(a1),
       B.ExprStmt(b1)
    )
    )
  | A.If(a1, a2, a3), B.If(b1, b2, b3) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    m_stmt a2 b2 >>= (fun (a2, b2) -> 
    m_stmt a3 b3 >>= (fun (a3, b3) -> 
    return (
       A.If(a1, a2, a3),
       B.If(b1, b2, b3)
    )
    )))
  | A.Do(a1, a2), B.Do(b1, b2) ->
    m_stmt a1 b1 >>= (fun (a1, b1) -> 
    m_expr a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.Do(a1, a2),
       B.Do(b1, b2)
    )
    ))
  | A.While(a1, a2), B.While(b1, b2) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    m_stmt a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.While(a1, a2),
       B.While(b1, b2)
    )
    ))
  | A.For(a1, a2), B.For(b1, b2) ->
    m_for_header a1 b1 >>= (fun (a1, b1) -> 
    m_stmt a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.For(a1, a2),
       B.For(b1, b2)
    )
    ))
  | A.Switch(a1, a2), B.Switch(b1, b2) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    (m_list m_case) a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.Switch(a1, a2),
       B.Switch(b1, b2)
    )
    ))
  | A.Continue(a1), B.Continue(b1) ->
    (m_option m_label) a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Continue(a1),
       B.Continue(b1)
    )
    )
  | A.Break(a1), B.Break(b1) ->
    (m_option m_label) a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Break(a1),
       B.Break(b1)
    )
    )
  | A.Return(a1), B.Return(b1) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Return(a1),
       B.Return(b1)
    )
    )
  | A.Label(a1, a2), B.Label(b1, b2) ->
    m_label a1 b1 >>= (fun (a1, b1) -> 
    m_stmt a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.Label(a1, a2),
       B.Label(b1, b2)
    )
    ))
  | A.Throw(a1), B.Throw(b1) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Throw(a1),
       B.Throw(b1)
    )
    )
  | A.Try(a1, a2, a3), B.Try(b1, b2, b3) ->
    m_stmt a1 b1 >>= (fun (a1, b1) -> 
    (m_option m_catch) a2 b2 >>= (fun (a2, b2) -> 
    (m_option m_stmt) a3 b3 >>= (fun (a3, b3) -> 
    return (
       A.Try(a1, a2, a3),
       B.Try(b1, b2, b3)
    )
    )))
  | A.VarDecl _, _
  | A.Block _, _
  | A.ExprStmt _, _
  | A.If _, _
  | A.Do _, _
  | A.While _, _
  | A.For _, _
  | A.Switch _, _
  | A.Continue _, _
  | A.Break _, _
  | A.Return _, _
  | A.Label _, _
  | A.Throw _, _
  | A.Try _, _
   -> fail ()

and m_var_or_expr a b = 
  m_either m_var m_expr a b
and m_vars_or_expr a b = 
  m_either (m_list m_var) m_expr a b

and m_catch a b = 
  match a, b with
  | (a1, a2), (b1, b2) ->
    m_name a1 b1 >>= (fun (a1, b1) -> 
    m_stmt a2 b2 >>= (fun (a2, b2) -> 
    return (
       (a1, a2),
       (b1, b2)
    )
    ))

and m_case a b = 
  match a, b with
  | A.Case(a1, a2), B.Case(b1, b2) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    m_stmt a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.Case(a1, a2),
       B.Case(b1, b2)
    )
    ))
  | A.Default(a1), B.Default(b1) ->
    m_stmt a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Default(a1),
       B.Default(b1)
    )
    )
  | A.Case _, _
  | A.Default _, _
   -> fail ()

and m_for_header a b = 
  match a, b with
  | A.ForClassic(a1, a2, a3), B.ForClassic(b1, b2, b3) ->
    m_vars_or_expr a1 b1 >>= (fun (a1, b1) -> 
    m_expr a2 b2 >>= (fun (a2, b2) -> 
    m_expr a3 b3 >>= (fun (a3, b3) -> 
    return (
       A.ForClassic(a1, a2, a3),
       B.ForClassic(b1, b2, b3)
    )
    )))
  | A.ForIn(a1, a2), B.ForIn(b1, b2) ->
    m_var_or_expr a1 b1 >>= (fun (a1, b1) -> 
    m_expr a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.ForIn(a1, a2),
       B.ForIn(b1, b2)
    )
    ))
  | A.ForClassic _, _
  | A.ForIn _, _
   -> fail ()

(* ------------------------------------------------------------------------- *)
(* Entities *)
(* ------------------------------------------------------------------------- *)

and m_property a b = 
  match a, b with
  | A.Field(a1, a2, a3), B.Field(b1, b2, b3) ->
    m_property_name a1 b1 >>= (fun (a1, b1) -> 
    (m_list m_property_prop) a2 b2 >>= (fun (a2, b2) -> 
    m_expr a3 b3 >>= (fun (a3, b3) -> 
    return (
       A.Field(a1, a2, a3),
       B.Field(b1, b2, b3)
    )
    )))
  | A.FieldSpread(a1), B.FieldSpread(b1) ->
    m_expr a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.FieldSpread(a1),
       B.FieldSpread(b1)
    )
    )
  | A.Field _, _
  | A.FieldSpread _, _
   -> fail ()

and m_property_prop a b = 
  match a, b with
  | A.Static, B.Static ->
    return (
       A.Static,
       B.Static
    )
  | A.Public, B.Public ->
    return (
       A.Public,
       B.Public
    )
  | A.Private, B.Private ->
    return (
       A.Private,
       B.Private
    )
  | A.Protected, B.Protected ->
    return (
       A.Protected,
       B.Protected
    )
  | A.Static, _
  | A.Public, _
  | A.Private, _
  | A.Protected, _
   -> fail ()


and m_fun_prop a b = 
  match a, b with
  | A.Get, B.Get ->
    return (
       A.Get,
       B.Get
    )
  | A.Set, B.Set ->
    return (
       A.Set,
       B.Set
    )
  | A.Generator, B.Generator ->
    return (
       A.Generator,
       B.Generator
    )
  | A.Async, B.Async ->
    return (
       A.Async,
       B.Async
    )
  | A.Get, _
  | A.Set, _
  | A.Generator, _
  | A.Async, _
   -> fail ()

and m_var_kind a b = 
  match a, b with
  | A.Var, B.Var ->
    return (
       A.Var,
       B.Var
    )
  | A.Let, B.Let ->
    return (
       A.Let,
       B.Let
    )
  | A.Const, B.Const ->
    return (
       A.Const,
       B.Const
    )
  | A.Var, _
  | A.Let, _
  | A.Const, _
   -> fail ()

and m_var a b = 
  match a, b with
  { A. 
  v_name = a1;
  v_kind = a2;
  v_init = a3;
  v_resolved = a4;
  },
  { B. 
  v_name = b1;
  v_kind = b2;
  v_init = b3;
  v_resolved = b4;
  } -> 
    m_name a1 b1 >>= (fun (a1, b1) -> 
    m_var_kind a2 b2 >>= (fun (a2, b2) -> 
    m_expr a3 b3 >>= (fun (a3, b3) -> 
    (m_ref m_resolved_name) a4 b4 >>= (fun (a4, b4) -> 
    return (
      { A. 
      v_name = a1;
      v_kind = a2;
      v_init = a3;
      v_resolved = a4;
      },
      { B.
      v_name = b1;
      v_kind = b2;
      v_init = b3;
      v_resolved = b4;
      } 
    )
  ))))

and m_fun_ a b = 
  match a, b with
  { A. 
  f_props = a1;
  f_params = a2;
  f_body = a3;
  },
  { B. 
  f_props = b1;
  f_params = b2;
  f_body = b3;
  } -> 
    (m_list m_fun_prop) a1 b1 >>= (fun (a1, b1) -> 
    (m_list m_parameter) a2 b2 >>= (fun (a2, b2) -> 
    m_stmt a3 b3 >>= (fun (a3, b3) -> 
    return (
      { A. 
      f_props = a1;
      f_params = a2;
      f_body = a3;
      },
      { B.
      f_props = b1;
      f_params = b2;
      f_body = b3;
      } 
    )
  )))

(* ------------------------------------------------------------------------- *)
(* Class definition *)
(* ------------------------------------------------------------------------- *)
and m_obj_ a b = 
  match a, b with
  (a, b) -> (m_list m_property) a b

and m_class_ a b = 
  match a, b with
  { A. 
  c_extends = a1;
  c_body = a2;
  },
  { B. 
  c_extends = b1;
  c_body = b2;
  } -> 
    (m_option m_expr) a1 b1 >>= (fun (a1, b1) -> 
    (m_list m_property) a2 b2 >>= (fun (a2, b2) -> 
    return (
      { A. 
      c_extends = a1;
      c_body = a2;
      },
      { B.
      c_extends = b1;
      c_body = b2;
      } 
    )
  ))

(* ------------------------------------------------------------------------- *)
(* Misc *)
(* ------------------------------------------------------------------------- *)


and m_parameter a b = 
  match a, b with
  { A. 
  p_name = a1;
  p_default = a2;
  p_dots = a3;
  },
  { B. 
  p_name = b1;
  p_default = b2;
  p_dots = b3;
  } -> 
    m_name a1 b1 >>= (fun (a1, b1) -> 
    (m_option m_expr) a2 b2 >>= (fun (a2, b2) -> 
    m_bool a3 b3 >>= (fun (a3, b3) -> 
    return (
      { A. 
      p_name = a1;
      p_default = a2;
      p_dots = a3;
      },
      { B.
      p_name = b1;
      p_default = b2;
      p_dots = b3;
      } 
    )
  )))

(* ------------------------------------------------------------------------- *)
(* Module *)
(* ------------------------------------------------------------------------- *)

let m_module_directive a b = 
  match a, b with
  | A.Import(a1, a2, a3), B.Import(b1, b2, b3) ->
    m_name a1 b1 >>= (fun (a1, b1) -> 
    m_name a2 b2 >>= (fun (a2, b2) -> 
    m_filename a3 b3 >>= (fun (a3, b3) -> 
    return (
       A.Import(a1, a2, a3),
       B.Import(b1, b2, b3)
    )
    )))
  | A.Export(a1), B.Export(b1) ->
    m_name a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.Export(a1),
       B.Export(b1)
    )
    )
  | A.Import _, _
  | A.Export _, _
    -> fail ()

  | A.ImportCss _, _
  | A.ImportEffect _, _
  | A.ModuleAlias _, _
    -> raise Todo

(* ------------------------------------------------------------------------- *)
(* Toplevel *)
(* ------------------------------------------------------------------------- *)

let m_toplevel a b = 
  match a, b with
  | A.V(a1), B.V(b1) ->
    m_var a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.V(a1),
       B.V(b1)
    )
    )
  | A.M(a1), B.M(b1) ->
    m_module_directive a1 b1 >>= (fun (a1, b1) -> 
    return (
       A.M(a1),
       B.M(b1)
    )
    )
  | A.S(a1, a2), B.S(b1, b2) ->
    m_tok a1 b1 >>= (fun (a1, b1) -> 
    m_stmt a2 b2 >>= (fun (a2, b2) -> 
    return (
       A.S(a1, a2),
       B.S(b1, b2)
    )
    ))

  | A.V _, _
  | A.S _, _
  | A.M _, _
   -> fail ()



let m_program a b = 
  match a, b with
  (a, b) -> (m_list m_toplevel) a b


end
